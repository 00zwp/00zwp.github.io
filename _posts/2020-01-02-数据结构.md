---
layout:     post
title:      数据结构
subtitle:   "用C/C++, Python, Java实现一些基本的数据结构和相关的操作"
date:       2020-01-02
author:     tianhaoo
header-img: img/post-bg/43.jpg
catalog: true
tags:
  - 数据结构
---

## 记录基本的数据结构知识

### 单链表

#### 常量和类型定义


C```
typedef struct LNode{
    ElemType data;
    struct LNode* next;
}LNode, *LinkList;

Linklist L = (Node*)malloc(sizeof(Node));
```

Python```
class LNode:
    def __init__(self, elem):
        self.data = elem
        self.next = None
class LinkList:
    def __init__(self, node=None):
        self.head = node

L = LinkList(LNode("头节点"))
```

Java```

```

#### 一些题目

1. 求带头结点的单链表长度。

C```
int Length(LinkList L){
    Node* p = L;
    int count = 0;
    while(p->next != NULL){
        count++;
        p = p->next;
    }
    return count;
}
```


2. 用尽可能短的时间，将两个带头结点的单链表连接在一起。

C```
void Connect(LinkList &ha, LinkList &hb, int m, int n, LinkList &hc){
    // 将ha和hb指向的单链表合并，用hc传出来
    Linklist hd;
    if(m<=n){
        hc = ha;
        hd = hb;
    }// hc指向短的，hd指向长的
    Node* p = hc;
    while(p->next != NULL){
        p = p->next;
    }
    p->next = hd->next;
    free(hd);
    ha = NULL;
    hb = NULL;
}
```

3. 一个递增有序的带头结点的单链表，写一个高效算法，删除所有值相同的多余元素

C```
void Purge(LinkList L){
    if(L->next != NULL){
        Node* p = L->next;
        while(p->next != NULL){
            if (p->data == p->next->data){
                q = p->next;
                p->next = q->next;
                free(q);
            }else{
                p = p->next;
            }
        }
    }
}
```

4. 单链表就地逆置

C/C++
```
void Reverse(LinkList &L){
    if(L->next!=NULL){
        p = L->next;
        L->next = NULL;
        do{
            q = p->next;
            p->next = L->next;
            L->next = q;
        }while(p!=NULL);
    }
}
```

5. 已知有一个指针指向单链表中的某个结点，以尽可能快的方式删除这个结点。

C/C++
```
void Delete(Node* s, ElemType e){
    e = s->data;
    s->data = s->next->data;
    s->next = s->next->next;
}
```

6. 编写递归算法，求单链表长度(无头结点)
C/C++
```
int Length(LinkList L){
    if(L==NULL){
        return 0;
    }else{
        return Length(L->next) + 1;
    }
}
```


7. 编写递归算法，释放单链表的空间(无头结点)

C/C++
```
void free(LinkList &L){
    if (L!=NULL){
        Delete(L->next);
        free(L);
        L = NULL;
    }
}
```

8. 编写递归算法，逆序输出单链表(无头结点)

C/C++
```
void Write(LinkList L){
    if(L != NULL){
        Write(L->next);
        printf(L->data);
    }
}
```

9. 编写递归算法，判断单链表中是否有元素的值和位序相等的元素(无头结点)

C/C++
```
void Exsist(LinkList L, int position){
    if (L==NULL){
        return False;
    }else if(L->data == position){
        return True;
    }else{
        return Exsist(L->next, position+1);
    }
}
```

### 树

#### 常量和类型定义

C/C++
```
typedef struct BiNode{
    ElemType data;
    struct BiNode* lchild;
    struct BiNode* rchild;
}BiNode, *BiTree;

typedef struc CSNode{
    ElemType data;
    struct CSNode* firstchild;
    struct CSNode* nextsibling;
}CSNode, *CSTree;
```

#### 一些题目

1. 二叉树不是树的特例

2. 二叉树的五种基本形态

3. 二叉树的中序序列（树的后根序列） + 任一个其他序列 唯一确定一个二叉树或树

    先序：根左右
    中序：左根右
    后序：左右根
    逆中序：右根左
    逆后序：根右左
    树的后根序列即对应二叉树的中序序列

4. 递归遍历二叉树

C/C++
```
void PreOrder(BiTree T){
    visit(*T);
    PreOrder(T->lchild);
    PreOrder(T->rchild);
}

```

5. 非递归先序遍历二叉树

C/C++
```
void PreOrder(BiTree T){
    InitStack(s);
    Push(s, NULL);
    p=T
    while(p!=NULL){
        while(p!=NULL){
            visit(*T);
            if(p->rchild!=NULL){
                Push(s, p);
            }
            p = p->lchild;
        }
        Pop(s, p);
    }
}
```

6. 删除子树，释放占用的空间

C/C++
```
void Delete(BiTree &T){
    if(T!=NULL){
        Delete(T->lchild);
        Delete(T->rchild);
        free(T);
        T=NULL;
    }
}
```

7. 判断两棵二叉树是否相似/镜像/相等

C/C++
```
Status Similar(BiTree T1, BiTree T2){
    if (T1==NULL && T2==NULL){
        return True;
    }else if(T1==NULL && T2!=NULL){
        return False;
    }else if(T1!=NULL && T2==NULL){
        return False;
    }else{
        return Similar(T1->lchild, T2->lchild) && Similar(T1->rchild, T2->rchild);
    }
}
```

8. 交换一个二叉树的左右子树

C/C++
```
void Swap(BiTree T){
    Swap(T->lchild);
    Swap(T->rchild);
    temp = T->lchild;
    T->lchild = T->rchild;
    T->rchild = temp;
}
```

9. 求一个二叉树的高度（利用二叉树的五种形态）

C/C++
```
int Depth(BiTree T){
    if(T==NULL){
        return 0;
    }else{
        return 1 + max(Depth(T->lchild), Depth(T->rchild));
    }
}
```

10. 求一个二叉树的高度（利用带一个参数遍历的方法）

C/C++
```
void Depth(BiTree T, int level, int &d){
    if(T!=NULL){
        if(level > d){
            d = level;
        }
        Depth(T->lchild, level+1, d);
        Depth(T->rchild, level+1, d);
    }
}
```

11. 求二叉树度为0的结点（叶子结点）个数

C/C++
```
int Count(BiTree T){
    if(T==NULL){
        return 0;
    }else if(T->lchild==NULL && T->rchild==NULL){
        return 1;
    }else{
        return Count(T->lchild) + Count(T->rchild);
    }
}
```

12. 求二叉树度为1的结点

C/C++
```
int Count(BiTree T){
    if (T==NULL){
        return 0;
    }else if(T->lchild!=NULL && T->rchild==NULL){
        return 1 + Count(T->lchild);
    }else if(T->lchild==NULL && T->rchild!=NULL){
        return 1 + Count(T->rchild);
    }else{
        return Count(T->lchild) + Count(T->rchild);
    }
}
```

13. 将一棵二叉树根朝左，躺倒打印出来（见严蔚敏习题集）

    逆中序遍历次序决定行数
    结点所在的层数决定列数

C/C++
```
```

